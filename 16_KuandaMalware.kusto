// Identify unusual DetectiveIds
let _encryptedmessages = 
KuandaLogs
| where Message !startswith "Operation" and Message !startswith "User"
| distinct DetectiveId;
// Identify Start and End time for each encrypted message for each DetectiveId
let _encryptionkeysearchspace = 
KuandaLogs
| where DetectiveId in (_encryptedmessages)
| partition hint.strategy=native by DetectiveId
(
    order by Timestamp asc 
    | scan with_match_id=id declare(SessionStartTime:datetime, SessionEndTime:datetime) with (
        step start output=none: 
            Message has 'User entered the system' or Message has 'User session reset' => SessionStartTime = Timestamp;
        step encryptedmessage: 
            Message startswith 'Sending an encrypted message' => SessionEndTime = Timestamp, SessionStartTime = start.SessionStartTime;
    )
    | project DetectiveId, SessionStartTime, SessionEndTime, Message
);
// Extract tokens and IDs from the "started" messages
let startedTokens =
KuandaLogs
| parse-where Message with "Operation id=" OperationId " started ('" CaseActionType "'). Captured user encryption token: '" Token "'."
| project DetectiveId, OperationId, CaseActionType, Token, startedTimestamp = Timestamp;
// Extract IDs from the "completed" messages
let completedOperations =
KuandaLogs
| parse-where Message with "Operation id=" OperationId " completed: user encryption token for this operation is disposed."
| project DetectiveId, OperationId, completeTimestamp = Timestamp;
let DecryptionTable = 
_encryptionkeysearchspace
| join kind=inner startedTokens on DetectiveId
| where startedTimestamp <= SessionEndTime and startedTimestamp >= SessionStartTime
// Join with completed tokens to get the completeTimestamp, if it exists
| join kind=leftouter completedOperations on OperationId
| extend isDisposedAfterEncryptedMsg = isnull(completeTimestamp) or completeTimestamp > SessionEndTime
| where isDisposedAfterEncryptedMsg == true
| summarize Tokens = make_list(Token), Timestamps = make_list(startedTimestamp) by Message
| extend (SortedTimestamps, SortedTokens) = array_sort_asc(Timestamps, Tokens)
| extend DecryptionKey = strcat_array(SortedTokens, '')
| parse Message with * "Dekrypt(@'" Content "', " *
| project Key = DecryptionKey, Message = Content;
// Invoke the Dekrypt function on this table
DecryptionTable
| invoke Dekrypt()
| project-away Key, Message
| parse Result with * "] " LogData
| project Result
// After identifying the message that we're looking for we'll define the address of our dataexplorer cluster and then find the number that gives false. Huge thanks to Salvatore Cavallaro for helping me with this!
let dataexplorerid = '';
range n from 0 to 100000000 step 1
| project test_value = n
| extend result = bitset_count_ones(hash_many(tostring(dataexplorerid), tostring(test_value))) < 54
| where result == false